<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../arc-polyfills/arc-polyfills.html">
<link rel="import" href="../jexl/jexl.html">
<!--
`<variables-evaluator>` Variables evaluator for the Advanced REST Client

The element listens for `before-request` custom event and evaluates its
properties. This element is responsible for applying variables to the request.

This elements works with `variables-manager`. When evaluation has been requested
it asks the manager for list of current variables. After the list is evaluated
then the requested value is evaluated for the variables.

### Example
```
<variables-evaluator></variables-evaluator>
```

A value can be evaluated on demand by dispatching `evaluate-variable` custom
event. It will perform evaluation on the `value` property of the detail object.
The element adds a `result` property to the detail object which is a Promise
that resolves to a value.
The event is cancelled and it's propagation is stopped so other evaluators won't
perform the same task again.

### Example

```javascript
// requesting to create an environment
var event = new CustomEvent('evaluate-variable', {
  bubbles: true,
  composed: true,
  cancelable: true,
  detail: {
    value: 'The timestamp is now() and generating random() value'
  }
});
document.dispatchEvent(event);
console.log(event.defaultPrevented); // true
event.detail.result.then(function(value) {
  console.log(value);
})
.catch(function(cause) {
  console.log(cause.message);
});
```

@group Logic Elements
@element variables-evaluator
-->
<script>
function VariablesTokenizer(value) {
  this.value = value;
  this.index = 0;
}
VariablesTokenizer.prototype.next = function() {
  var char = this.value[this.index];
  this.index++;
  return char;
};
VariablesTokenizer.prototype.nextUntil = function(char) {
  var result = '';
  while (true) {
    var ch = this.next();
    if (ch === undefined) {
      return null;
    }
    if (ch === char) {
      return result;
    }
    result += ch;
  }
};
VariablesTokenizer.prototype.eof = function() {
  var result = this.value.substr(this.index);
  this.index = this.value.length;
  return result;
};
Polymer({
  is: 'variables-evaluator',
  properties: {
    functionRegex: {
      type: RegExp,
      value: function() {
        return /([\.a-zA-Z0-9_-]+)\(([^)]*)?\)/gm;
      }
    },
    // A cache object for groupping
    cache: Object,
    // Cached context for current operation.
    context: Object
  },

  attached: function() {
    this.listen(window, 'before-request', '_beforeRequestHandler');
    this.listen(window, 'evaluate-variable', '_evaluateVariableHandler');
  },

  detached: function() {
    this.unlisten(window, 'before-request', '_beforeRequestHandler');
    this.unlisten(window, 'evaluate-variable', '_evaluateVariableHandler');
  },

  _beforeRequestHandler: function(e) {
    var promise = new Promise(function(request, resolve, reject) {
      this.cache = undefined;
      this.context = undefined;
      this._processBeforeRequest(request, resolve, reject);
    }.bind(this, e.detail));
    e.detail.promises.push(promise);
  },

  _processBeforeRequest: function(request, resolve, reject) {
    var p = ['url', 'method', 'headers', 'payload']
    .map(function(property) {
      return this.evaluateVariable(request[property])
      .then(function(value) {
        return {
          property: property,
          value: value
        };
      });
    }, this);
    return Promise.all(p)
    .then(function(results) {
      results.forEach(function(item) {
        request[item.property] = item.value;
      });
      return request;
    })
    .then(function(request) {
      resolve(request);
    })
    .catch(function(cause) {
      reject(cause);
    });
  },

  _evaluateVariableHandler: function(e) {
    if (e.defaultPrevented) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    e.detail.result = new Promise(function(value, resolve, reject) {
      this.cache = undefined;
      this.context = undefined;
      this._processVariableEvaluation(value, resolve, reject);
    }.bind(this, e.detail.value));
  },

  _processVariableEvaluation: function(value, resolve, reject) {
    return this.evaluateVariable(value)
    .then(function(result) {
      resolve(result);
    })
    .catch(function(cause) {
      reject(cause);
    });
  },
  /**
   * Evaluates a value against a variables.
   *
   * @param {String} value A value to evaluate
   * @param {?Object} context Optional. Context for Jexl. If not set it will
   * get a context from variables manager.
   * @return {Promise<String>} Promise that resolves to evaluated value.
   */
  evaluateVariable: function(value, context) {
    var typeOf = typeof value;
    // Non primitives + null
    if (typeOf === 'object') {
      return Promise.resolve(value);
    }
    if (typeOf !== 'string') {
      value = String(value);
    }
    var promise;
    if (context) {
      promise = Promise.resolve(context);
    } else if (this.context) {
      promise = Promise.resolve(this.context);
    } else {
      promise = this._buildContext();
    }
    return promise.then(function(context) {
      try {
        value = this._updgradeLegacy(value);
        value = this._evalFunctions(value);
        if (!value || !~value.indexOf('${')) {
          return Promise.resolve(value);
        }
        value = this._prepareValue(value);
      } catch (e) {
        return Promise.reject(e);
      }
      if (!this._jexl) {
        try {
          this._jexl = require('Jexl');
        } catch (e) {
          return Promise.reject(e);
        }
      }
      return this._jexl.eval(value, context);
    }.bind(this));
  },
  /**
   * Requests for a variables list from the variables manager
   * and creates a context for Jexl.
   *
   * @return {Object} The context to be passed to Jaxl.
   */
  _buildContext: function() {
    var event = this.fire('variable-list', {}, {
      cancelable: true
    });
    var result = {};
    if (!event.defaultPrevented) {
      return Promise.resolve(result);
    }
    var variables = event.detail.value;
    if (!variables || !variables.length) {
      return Promise.resolve(result);
    }
    // Filter out disabled items
    variables = variables.filter(function(item) {
      return item.enabled;
    });
    variables = variables.map(function(item) {
      return Object.assign({}, item);
    });

    return this._processContextVariables(result, variables);
  },

  _processContextVariables: function(result, variables, requireEvaluation, runCount) {
    requireEvaluation = requireEvaluation || variables.filter(function(item) {
      return !!~item.value.indexOf('${');
    });
    variables.forEach(function(item) {
      result[item.variable] = item.value;
    });
    if (requireEvaluation.length === 0) {
      return Promise.resolve(result);
    }
    // this array should be sorted so items that should be evaluated first
    // because are a dependencies of other expressions.
    var promises = requireEvaluation.map(function(item) {
      return this.evaluateVariable(item.value, result)
      .then(function(value) {
        item.value = value;
        return item;
      });
    }, this);
    return Promise.all(promises)
    .then(function(items) {
      items.forEach(function(item) {
        result[item.variable] = item.value;
      });
      requireEvaluation = items.filter(function(item) {
        return !!~item.value.indexOf('${');
      });
      runCount = runCount || 1;
      if (requireEvaluation.length === 0 || runCount >= 2) {
        this.context = result;
        return result;
      }
      runCount++;
      return this._processContextVariables(result, variables, requireEvaluation, runCount);
    }.bind(this));
  },
  /**
   * Upgrades old syntax of magic variables to new one.
   * It replaces `${now}` and `${random}` to function calls: `now()` and
   * `random()`. It also keeps grouping.
   *
   * @param {String} value Currently evaluated value
   * @return {String} Parsed value without old syntax.
   */
  _updgradeLegacy: function(value) {
    var reg = /\${(random|now):?([0-9]+)?}/gm;
    var test = reg.test(value);
    if (!test) {
      return value;
    }
    reg.lastIndex = 0;
    while (true) {
      var matches = reg.exec(value);
      if (!matches) {
        break;
      }
      var variable = matches[0];
      var word = matches[1];
      var group = matches[2];
      var replacement = word + '(';
      if (group) {
        replacement += group;
      }
      replacement += ')';
      value = value.replace(variable, replacement);
      reg.lastIndex -= 2; // replacement word is shorter by 2 characters
    }
    return value;
  },
  /**
   * Replaces strings witht quoted string and variables notation into
   * variables that Jexl will understand.
   *
   * @param {String} value Value to evaluate
   * @return {String} Proper syntax for Jexl
   */
  _prepareValue: function(value) {
    if (!value || !~value.indexOf('${')) {
      return value;
    }
    var tokenizer = new VariablesTokenizer(value);
    var parsed = '';
    while (true) {
      var _startIndex = tokenizer.index;
      var left = tokenizer.nextUntil('$');
      if (left === null) {
        // no more variables
        if (!parsed) {
          return value;
        }
        tokenizer.index = _startIndex;
        parsed += '"' + tokenizer.eof() + '"';

        return parsed;
      }
      var variable = tokenizer.nextUntil('}');
      if (!variable) {
        throw new Error('Syntax error. Unclosed curly bracket.');
      }
      variable = variable.substr(1);
      var replacement = ' + ' + variable + ' + ';

      var newValue = '';
      newValue += '"' + left + '"';
      newValue += replacement;
      parsed += newValue;
    }
    return value;
  },
  /**
   * Evaluates functions.
   *
   * @param {String} value A value to evaluate
   * @return {String} Evaluated value with removed functions.
   * @throws Error if a function is not supported.
   */
  _evalFunctions: function(value) {
    if (!value) {
      return;
    }
    var re = this.functionRegex;
    re.lastIndex = 0;
    var matches;
    while ((matches = re.exec(value))) {
      var fnName = matches[1];
      var args = matches[2];
      if (args) {
        args = args.split(',').map(function(item) {
          return item.trim();
        });
      }
      var _value = this._callFn(fnName, args);
      value = value.replace(matches[0], _value);
      re.lastIndex -= (matches[0].length - String(_value).length);
    }
    return value;
  },
  /**
   * Calls one of the predefined functions and returns its value.
   *
   * @param {String} fnName A function name to call.
   * @param {?Array} args Arguments find in the expression.
   * @return {String} Result of calling a function. Always a string.
   */
  _callFn: function(fnName, args) {
    var dotIndex = fnName.indexOf('.');
    if (~dotIndex) {
      var namespace = fnName.substr(0, dotIndex);
      var name = fnName.substr(dotIndex + 1);
      if (~['Math', 'String', 'JSON'].indexOf(namespace)) {
        try {
          return this._callNamespaceFunction(namespace, name, args);
        } catch (e) {
          throw new Error('Unsuppored function ' + fnName);
        }
      }
    } else {
      fnName = fnName[0].toUpperCase() + fnName.substr(1);
      var localFnName = '__evalFn' + fnName;
      if (typeof this[localFnName] === 'function') {
        return this[localFnName](args);
      }
    }
    this.fire('app-log', {
      'message': ['Variables evaluator', 'Function not found', fnName],
      'level': 'error'
    });
    console.error('Function not found', fnName);
    throw new Error('Unsuppored function ' + fnName);
  },

  _applyArgumentsContext: function(arg, context) {
    if (arg.indexOf('${') === 0) {
      arg = arg.substr(2, arg.length - 3);
      if (context[arg]) {
        return context[arg];
      }
    }
    return arg;
  },
  /**
   * Calls JavaScript native function.
   *
   * @param {[type]} namespace [description]
   * @param {Function} fn [description]
   * @param {[type]} args [description]
   * @return {[type]} [description]
   */
  _callNamespaceFunction: function(namespace, fn, args) {
    var context = this.context;
    if (context) {
      args = args.map(function(arg) {
        return this._applyArgumentsContext(arg, context);
      }, this);
    }

    if (namespace === 'Math' || namespace === 'JSON') {
      return window[namespace][fn].apply(window, args);
    } else if (namespace === 'String') {
      if (!args || !args.length) {
        this.fire('app-log', {
          'message': ['Variables evaluator',
            'String functions need an argument'],
          'level': 'error'
        });
        console.error('String functions need an argument. None given.');
        throw new Error('String functions need an argument');
      }
      var str = args.shift();
      return String.prototype[fn].apply(str, args);
    }
  },
  /**
   * Finds cached group.
   *
   * @param {String} key A key where a function keeps cached objects
   * @param {String} group Group name. Defined by user as an argument.
   * @return {String} Cached value.
   */
  _findInCache: function(key, group) {
    if (!this.cache) {
      return;
    }
    if (!this.cache[key]) {
      return;
    }
    return this.cache[key][group];
  },
  /**
   * Stores value in cache.
   *
   * @param {String} key A key where a function keeps cached objects
   * @param {String} group Group name. Defined by user as an argument.
   * @param {String} value Cached value.
   */
  _storeCache: function(key, group, value) {
    if (!this.cache) {
      this.cache = {};
    }
    if (!this.cache[key]) {
      this.cache[key] = {};
    }
    this.cache[key][group] = value;
  },
  /**
   * Calls the `now()` function. Returns current timestamp.
   * If argument is passed is will try to retreive existing cached value
   * or create new one.
   *
   * @param {Array} args Arguments passed to the function
   * @return {Number} Current timestamp
   */
  __evalFnNow: function(args) {
    var key = '__evalFnNow';
    var hasGroup = !!(args && args[0]);
    var value;
    if (hasGroup) {
      value = this._findInCache(key, args[0]);
    }
    if (!value) {
      value = Date.now();
    }
    if (hasGroup) {
      this._storeCache(key, args[0], value);
    }
    return value;
  },

  __evalFnRandom: function(args) {
    var key = '__evalFnRandom';
    var hasGroup = !!(args && args[0]);
    var value;
    if (hasGroup) {
      value = this._findInCache(key, args[0]);
    }
    if (!value) {
      value = this.__randomInt();
    }
    if (hasGroup) {
      this._storeCache(key, args[0], value);
    }
    return value;
  },

  /**
   * Returns a random <code>int</code> between 0 (inclusive) and
   * <code>Number.MAX_SAFE_INTEGER</code> (exclusive) with roughly equal probability of
   * returning any particular <code>int</code> in this range.
   */
  __randomInt: function() {
    // "|0" forces the value to a 32 bit integer.
    // Number.MAX_SAFE_INTEGER
    return Math.abs((Math.floor(Math.random() * 9007199254740991)) | 0);
  },

  __evalFnEncodeURIComponent: function(args) {
    var value = args && args[0];
    if (!value) {
      throw new Error('encodeURIComponent() requires a value');
    }
    return encodeURIComponent(value);
  },

  __evalFnDecodeURIComponent: function(args) {
    var value = args && args[0];
    if (!value) {
      throw new Error('decodeURIComponent() requires a value');
    }
    return decodeURIComponent(value);
  }
});
</script>
